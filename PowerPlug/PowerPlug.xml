<?xml version="1.0"?>
<doc>
    <assembly>
        <name>PowerPlug</name>
    </assembly>
    <members>
        <member name="T:PowerPlug.BaseCmdlets.WritableByname">
            <summary>
            Fill out
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.Name">
            <summary>
            The Name parameter for the command.
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.Scope">
            <summary>
            The scope parameter for the command determines which scope the alias is set in.
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.Force">
            <summary>
            If set to true and an existing alias of the same name exists
            and is ReadOnly, the alias will be overwritten.
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.Value">
            <summary>
            The Value parameter for the command.
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.Description">
            <summary>
            The description for the alias.
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.Option">
            <summary>
            The Option parameter allows the alias to be set to
            ReadOnly (for existing aliases) and/or Constant (only
            for new aliases).
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.PassThru">
            <summary>
            If set to true, the alias that is set is passed to the pipeline.
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.WhatIf">
            <summary>
            
            </summary>
        </member>
        <member name="P:PowerPlug.BaseCmdlets.WritableByname.Confirm">
            <summary>
            
            </summary>
        </member>
        <member name="T:PowerPlug.Cmdlets.CompareHashCmdlet">
            <summary>
            <para type="synopsis">Compares a file's user specified hash with another signature</para>
            <para type="description">This function will compare a user defined hash of a file, such as an executable with the known signature of the file. 
            This is especially useful since hashed values are long. The current supported hashes are SHA256, SHA512, MD5.
            </para>
            <para type="aliases">trash</para>
            <example>
            <para>A sample Compare-Sha256 command</para>
            <code>Compare-Hash .\audacity-win-2.4.2.exe 1f20cd153b2c322bf1ff9941e4e5204098abdc7da37250ce3fb38612b3e927bc</code>
            </example>
            </summary>
        </member>
        <member name="P:PowerPlug.Cmdlets.CompareHashCmdlet.Hash">
            <summary>
            <para type="description">The hashing algorithm (SHA256, SHA512, MD5) to use when comparing the signature</para>
            </summary>
        </member>
        <member name="P:PowerPlug.Cmdlets.CompareHashCmdlet.Path">
            <summary>
            <para type="description">The path to the file</para>
            </summary>
        </member>
        <member name="P:PowerPlug.Cmdlets.CompareHashCmdlet.Signature">
            <summary>
            <para type="description">The the known SHA256 signature of the file</para>
            </summary>
        </member>
        <member name="M:PowerPlug.Cmdlets.CompareHashCmdlet.ProcessRecord">
            <summary>
            <para type="description">Processes the PSCmdlet</para>
            </summary>
            <exception cref="T:System.NotImplementedException"></exception>
        </member>
        <member name="M:PowerPlug.Cmdlets.CompareHashCmdlet.ConvertHashAlgorithmToX2FormattedString(System.Security.Cryptography.HashAlgorithm,System.String)">
            <summary>
            Converts a <see cref="T:System.Security.Cryptography.HashAlgorithm"/> to the Path specified by the PSCmdlet
            </summary>
            <param name="ha">The HashAlgorithm instance</param>
            <param name="filePath">The Path property</param>
            <returns>a Base64 encoded string</returns>
        </member>
        <member name="T:PowerPlug.Cmdlets.MoveTrashCmdlet">
            <summary>
            <para type="synopsis">Moves a file to the Recycle Bin</para>
            <para type="description">This function will move a file, whether directory or file, to the system Recycle Bin.
            <para type="aliases">trash</para>
            If the param list is true, it will print the contents of the current directory after recycling the file. 
            Only error dialogs are printed and no confirmation message is shown.
            </para>
            <example>
            <para>A sample Move-Trash command</para>
            <code>Move-Trash -Path Documents\file.txt -List</code>
            </example>
            </summary>
        </member>
        <member name="P:PowerPlug.Cmdlets.MoveTrashCmdlet.Path">
            <summary>
            <para type="description">The path to the file</para>
            </summary>
        </member>
        <member name="P:PowerPlug.Cmdlets.MoveTrashCmdlet.List">
            <summary>
            <para type="description">A flag indicating whether to print the contents of the current directory</para>
            </summary>
        </member>
        <member name="M:PowerPlug.Cmdlets.MoveTrashCmdlet.ProcessRecord">
            <summary>
            Processes the PSCmdlet
            </summary>
        </member>
        <member name="P:PowerPlug.Cmdlets.RemoveBynameCmdlet.Name">
            <summary>
            The Name parameter for the command.
            </summary>
        </member>
        <member name="P:PowerPlug.Cmdlets.RemoveBynameCmdlet.Scope">
            <summary>
            The scope parameter for the command determines which scope the alias is set in.
            </summary>
        </member>
        <member name="P:PowerPlug.Cmdlets.RemoveBynameCmdlet.Force">
            <summary>
            If set to true and an existing alias of the same name exists
            and is ReadOnly, the alias will be overwritten.
            </summary>
        </member>
        <member name="M:PowerPlug.Cmdlets.RemoveBynameCmdlet.ProcessRecord">
            <inheritdoc cref="T:PowerPlug.Engines.Byname.Base.BynameCreatorStrategy"/>
        </member>
        <member name="T:PowerPlug.Cmdlets.SetBynameCmdlet">
            <summary>
            <para type="synopsis">Set's an alias within the profile instead of the session</para>
            <para type="description">Set's an alias using Set-Byname, but writes to the $PROFILE instead of the session
            </para>
            <para type="aliases">sbn</para>
            <example>
            <para>A sample Set-Alias command</para>
            <code>Set-Byname -Name list -Value Get-ChildItem</code>
            </example>
            </summary>
        </member>
        <member name="T:PowerPlug.PowerPlugUtilities.Extensions.StringBuilderExtensions">
            <summary>
            
            </summary>
        </member>
        <member name="M:PowerPlug.PowerPlugUtilities.Extensions.StringBuilderExtensions.AppendIf(System.Text.StringBuilder,System.String,System.Boolean)">
            <summary>
            
            </summary>
            <param name="this"></param>
            <param name="str"></param>
            <param name="condition"></param>
            <returns></returns>
        </member>
        <member name="T:PowerPlug.PowerPlugUtilities.Range`1">
            <summary>The Range class which was modified from user @drharris on StackOverflow.</summary>
            <typeparam name="T">Generic parameter.</typeparam>
        </member>
        <member name="P:PowerPlug.PowerPlugUtilities.Range`1.Minimum">
            <summary>Minimum value of the range.</summary>
        </member>
        <member name="P:PowerPlug.PowerPlugUtilities.Range`1.Maximum">
            <summary>Maximum value of the range.</summary>
        </member>
        <member name="M:PowerPlug.PowerPlugUtilities.Range`1.ToString">
            <summary>Presents the Range in readable format.</summary>
            <returns>String representation of the Range</returns>
        </member>
        <member name="M:PowerPlug.PowerPlugUtilities.Range`1.IsValid">
            <summary>Determines if the range is valid.</summary>
            <returns>True if range is valid, else false</returns>
        </member>
        <member name="M:PowerPlug.PowerPlugUtilities.Range`1.ContainsValue(`0)">
            <summary>Determines if the provided value is inside the range.</summary>
            <param name="value">The value to test</param>
            <returns>True if the value is inside Range, else false</returns>
        </member>
        <member name="M:PowerPlug.PowerPlugUtilities.Range`1.IsInsideRange(PowerPlug.PowerPlugUtilities.Range{`0})">
            <summary>Determines if this Range is inside the bounds of another range.</summary>
            <param name="range">The parent range to test on</param>
            <returns>True if range is inclusive, else false</returns>
        </member>
        <member name="M:PowerPlug.PowerPlugUtilities.Range`1.ContainsRange(PowerPlug.PowerPlugUtilities.Range{`0})">
            <summary>Determines if another range is inside the bounds of this range.</summary>
            <param name="range">The child range to test</param>
            <returns>True if range is inside, else false</returns>
        </member>
    </members>
</doc>
